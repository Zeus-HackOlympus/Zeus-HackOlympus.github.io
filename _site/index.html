<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Zeus@HackOlympus</title>
  <meta name="description" content="A personal blog and mind dump of my CS journey ...">
  
  <script src="https://kit.fontawesome.com/6b8da6f1d0.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://hackolympus.com/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Zeus@HackOlympus" href="https://hackolympus.com/feed.xml">
  <!-- Global site tag (gtag.js) - Google Analytics -->
 <script async src="https://www.googletagmanager.com/gtag/js?id=G-MFNXHS9HDQ"></script>
 <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-MFNXHS9HDQ');
 </script>
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">


  
  <meta property="og:title" content="Zeus@HackOlympus">
  <meta property="og:site_name" content="Zeus@HackOlympus">
  <meta property="og:url" content="https://hackolympus.com/">
  <meta property="og:description" content="A personal blog and mind dump of my CS journey ...">
  
  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Zeus@HackOlympus">
  <meta name="twitter:description" content="A personal blog and mind dump of my CS journey ...">
  
  

  <link rel="dns-prefetch" href="https://fonts.gstatic.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bitter:ital,wght@0,400;0,700;1,400&amp;display=swap" rel="stylesheet">

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Zeus@HackOlympus</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">

  

  

  <ul class="post-list">
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            
              <a class="post-link" href="/blog/2023/05/15/heap-exploitation-notes-understanding-glibc-s-heap/">Heap Exploitation Notes: Understanding glibc&#39;s Heap</a>
            
          </h1>

          <p class="post-meta">
            May 15, 2023
            
            
          </p>
        </header>

        <div class="post-content">
          <h1>Heap</h1>

<p>Heap is very platform and implementation specific.
So windows and linux have different heap implementation. We are looking at glibc (linux) heap implementation.</p>

<h2>Arena</h2>

<ol>
  <li>every thread has a separate arena</li>
  <li>Arena is basically a separate heap per thread.</li>
  <li>there is a <strong>parent arena</strong> that is basically the first arena of the program.</li>
  <li>there are a total of <code class="language-plaintext highlighter-rouge">8 * number of cores</code> arenas.</li>
</ol>

<h2>malloc chunk</h2>

<p>chunks are the <strong>basic unit of memory</strong> in heap.</p>

<p>When the heap manager allocates memory from the heap, it typically <strong>allocates a chunk of memory that is larger than the requested size</strong>. This is because the heap manager also needs to <strong>store alignment padding and metadata with the allocated chunk</strong>, such as information about the size and status of the chunk. The metadata is stored alongside the chunk of memory, and so the overall size of the allocated block is larger than the size requested by the program.</p>

<p>alignment of chunk = <code class="language-plaintext highlighter-rouge">2 * sizeof(size_t)</code></p>

<p>so for 32 bit systems, allocation will be 8 byte aligned.
for 64 bit systems, allocation will be 16 bit aligned.</p>

<p>The heap manager will mark the chunk allocated and returns a pointer to the aligned “user data” region inside the chunk.</p>

<h3>Chunk Allocation strategies</h3>

<ol>
  <li>previously freed chunk of memory and chunk is big enough that same chunk gets allocated</li>
  <li>space available at top of heap, allocate space from top of heap</li>
  <li>otherwise, ask kernel to add new memory, then ask heap to allocate from top of heap</li>
  <li>if all fails, malloc returns <code class="language-plaintext highlighter-rouge">NULL</code></li>
</ol>

<h4>Allocating from freed chunks</h4>

<ol>
  <li>Heap manager keeps track of freed chunks in a series of different linked list called “bins”.</li>
  <li>when an allocation request is made, heap managers searches these bins for a chunk that is big enough to service the request.</li>
  <li>removes the chunk from the bin and mark it as allocated.</li>
  <li>returns pointer to user data.</li>
</ol>

<p>there are different types of bins:</p>
<ul>
  <li>fast bins</li>
  <li>unsorted bins</li>
  <li>small bins</li>
  <li>large bins</li>
  <li>per-thread tcache.</li>
</ul>

<!-- ![](https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-simple-CS.png) -->
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    An allocated chunk looks like this:


    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of previous chunk, if unallocated (P clear)  |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of chunk, in bytes                     |A|M|P|
      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             User data starts here...                          .
	    .                                                               .
	    .             (malloc_usable_size() bytes)                      .
	    .                                                               |
nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             (size of chunk, but used for application data)    |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of next chunk, in bytes                |A|0|1|
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre></div></div>

<h4>Allocating from top of heap</h4>

<ol>
  <li>if no free chunks available that can service request, heap manager <strong>allocates space from top of heap</strong>.</li>
  <li>heap manager first looks at the free space at the top of heap otherwise known as <strong>top chunk</strong>.</li>
</ol>

<h4>Asking kernel from more memory at the top of the heap</h4>

<ol>
  <li>Once the free space at the top of the heap is used up, the heap manager will have to ask the kernel to add more memory to the end of the heap.</li>
  <li>on the initial heap, the heap manager asks the kernel to allocate memory at the end of heap by calling the <code class="language-plaintext highlighter-rouge">sbrk</code> syscall.</li>
  <li><code class="language-plaintext highlighter-rouge">sbrk</code> internally uses <code class="language-plaintext highlighter-rouge">brk</code> syscall.</li>
  <li>Eventually, expanding the heap with sbrk will fail. Heap will grow so large that it will collide with libraries, or a thread’s stack region. Once the heap reaches this point, the heap manager will resort to attaching new non-contiguous memory to the initial program heap using calls to <code class="language-plaintext highlighter-rouge">mmap</code>.</li>
</ol>

<!-- ![](https://azeria-labs.com/wp-content/uploads/2019/03/process-memory-heap-gif-1.gif) -->

<h3>Chunk Metadata</h3>

<p>definition of chunk:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">malloc_chunk</span> <span class="p">{</span>

  <span class="n">INTERNAL_SIZE_T</span>   <span class="n">mchunk_prev_size</span><span class="p">;</span>  <span class="cm">/* Size of previous chunk (if free).  */</span>
  <span class="n">INTERNAL_SIZE_T</span>   <span class="n">mchunk_size</span><span class="p">;</span>       <span class="cm">/* Size in bytes, including overhead. */</span>

  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd</span><span class="p">;</span>         <span class="cm">/* double links -- used only if free. */</span>
  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk</span><span class="p">;</span>

  <span class="cm">/* Only used for large blocks: pointer to next larger size.  */</span>
  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd_nextsize</span><span class="p">;</span> <span class="cm">/* double links -- used only if free. */</span>
  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk_nextsize</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>During malloc, before returning the pointer to user data, chunk size is written in <code class="language-plaintext highlighter-rouge">mchunk_size</code> field. <code class="language-plaintext highlighter-rouge">mchunk_size</code> contains chunk size and 3 flags</p>

<p>the 3 flags are:</p>

<p><code class="language-plaintext highlighter-rouge">A</code> flag
if bit is 1, chunk is not from main arena
else chunk comes from main arena <br /> 
<code class="language-plaintext highlighter-rouge">M</code> flag
if bit is 1, chunk was allocated with <code class="language-plaintext highlighter-rouge">mmap</code> call and is not a part of
heap and was allocated off-heap. When freed the whole chunk is returned back
to OS via <code class="language-plaintext highlighter-rouge">munmap</code> syscall rather than attempting to recycle it.<br /> 
<code class="language-plaintext highlighter-rouge">P</code> flag
if bit is 1, previous chunk is in use, and should not used to safely join
with previous chunk to create much larger chunk<br /></p>

<h3>How does free works</h3>

<ol>
  <li>Check that <strong>allocation is aligned on an 8-byte boundary</strong>, since malloc ensures all allocations are aligned.</li>
  <li>Check that the chunk’s size field isn’t impossible - either because it is too small, too large, not aligned size or would overlap the with end of process’ address space.</li>
  <li>check that chunk lies within boundaries of arena.</li>
  <li>check that chunk is not already marked as free by checking the corresponding “P” bit that lies in the metadata at the start of next chunk.</li>
</ol>

<h3>Free chunk metadata</h3>

<p>Free chunks also have metadata.</p>

<p>They store <code class="language-plaintext highlighter-rouge">chunk size</code>, <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">P</code> field. They do not store <code class="language-plaintext highlighter-rouge">M</code> field because mmaped chunks get unmmaped right away.</p>

<h2>Bins</h2>

<ol>
  <li>a list structure (doubly or singly linked list) of non-allocated chunks.</li>
  <li>differentiated based on the size of chunks</li>
  <li>Bins keep the track of freed chunks.</li>
  <li>for performance reasons heap manager keeps track by maintaining a series of lists called “bins”, which are designed to maximize speed of allocation and frees.</li>
</ol>

<h3>Small bins</h3>

<ol>
  <li>There are 62 of them.</li>
  <li>Every chunk less than 512 bytes on 32 bits systems (and 1024 bytes in 64 bit systems) has a corressponding small bin.</li>
  <li>Each small bin stores only one size of chunk, they are automatically ordered, so insertion and removal of entries on these lists is incredibly fast.</li>
  <li>act as <strong>queue</strong></li>
</ol>

<!-- ![](https://azeria-labs.com/wp-content/uploads/2019/03/bins-small.png)  -->

<h3>Large Bins</h3>

<ol>
  <li>For chunks over 512 bytes (or 1024 bytes on 64 bit), heap manager uses “large bins”.</li>
  <li>instead storing the chunks of same size, they store chunks within a size range.</li>
  <li>insertions onto the bins have to be manually sorted, and allocations from the list require traversing the list. <strong>This makes large bins slower</strong>.</li>
  <li>Large bins are used less frequently because program tend to allocate small allocations.</li>
  <li>act as <strong>queue</strong></li>
</ol>

<h3>Unsorted bins</h3>

<ol>
  <li>Small and large chunks when freed end up in this bin.</li>
  <li>primary purpose of this bin is to act as a cache layer to speed up allocations and deallocations requests.</li>
</ol>

<h3>Fastbins</h3>

<ol>
  <li>A total of 10 fast bins.</li>
  <li>Contains chunk of same fixed size - 16, 24, 32, 40, 48, 56, 64, 72, 80 or 88 bytes.</li>
  <li><strong>Act as a stack</strong>.</li>
</ol>

<h3>tcache</h3>

<ol>
  <li>tcache is a caching structure in ptmalloc to speed up repeated (small) allocations. Like other bins, tcache comes into play when freeing a chunk.</li>
  <li>tcache is implemented by a single linked list.</li>
  <li>each tcache entry is differentiated by 16 bytes. So first entry is of 16 bytes, second is of 32 bytes, third is of 48 bytes so on …</li>
</ol>

<p>tcache structure looks like the following:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* There is one of these for each thread, which contains the
   per-thread cache (hence "tcache_perthread_struct").  Keeping
   overall size low is mildly important.  Note that COUNTS and ENTRIES
   are redundant (we could have just counted the linked list each
   time), this is for performance reasons.  
*/</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tcache_perthread_struct</span>
<span class="p">{</span>
  <span class="kt">uint16_t</span> <span class="n">counts</span><span class="p">[</span><span class="n">TCACHE_MAX_BINS</span><span class="p">];</span>
  <span class="n">tcache_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">[</span><span class="n">TCACHE_MAX_BINS</span><span class="p">];</span>
<span class="p">}</span> <span class="n">tcache_perthread_struct</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">counts</code> is an array of <code class="language-plaintext highlighter-rouge">TCACHE_MAX_BINS</code> elements. Each element store the count of i<sup>th</sup> entries.
<code class="language-plaintext highlighter-rouge">entries</code> is a linked list that acts as a stack. Each element stores the pointer to latest freed <code class="language-plaintext highlighter-rouge">tcache_entry</code>. By dividing the allocation size by 16 we can get the right bin to store the tcache entry.</p>

<p><a href="https://pwn.college/">pwn.college</a> has given a great graphical <a href="https://youtu.be/0jHtqqdVv1Y?t=270">explanation</a>:</p>

<p><img src="./pics/tcache.png" alt="" /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">tcache_entry</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">tcache_entry</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
  <span class="cm">/* This field exists to detect double frees.  */</span>
  <span class="kt">uintptr_t</span> <span class="n">key</span><span class="p">;</span>
<span class="p">}</span> <span class="n">tcache_entry</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">next</code> is a pointer to previously freed entry/chunk (tcache acts as stack). 
<code class="language-plaintext highlighter-rouge">key</code> is used to verify which thread the entry corresponds to.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Process-wide key to try and catch a double-free in the same thread.  */</span>
<span class="k">static</span> <span class="kt">uintptr_t</span> <span class="n">tcache_key</span><span class="p">;</span>
</code></pre></div></div>
<h4>When freeing</h4>

<ol>
  <li>we <strong>select</strong> the right bin.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>idx = (freed_allocation_size - 1) / 16
</code></pre></div>    </div>
  </li>
  <li>We <strong>check</strong> using the key field to see if entry hasn’t already been freed before(double-free):</li>
  <li>We <strong>push</strong> the freed allocation to the front of the disk.</li>
  <li>We <strong>record</strong> the <code class="language-plaintext highlighter-rouge">tcache_perthread_struct</code>(otherwise the key) associated with the freed allocation. This is because we need to record the association of chunk with the thread i.e with what thread does this chunk belong to.</li>
</ol>

<h4>When allocating</h4>

<ol>
  <li>We do everything we did during free but in reverse order.</li>
  <li>We <strong>select</strong> the bin.</li>
  <li>We <strong>check</strong> the appropiate cache for available entries.</li>
  <li>We <strong>reuse</strong> the allocation in front of the list if available.</li>
</ol>

<p>These are just the basic terminoligies and knowledge required to understand heap attacks. Next article will talk about different types of heap attacks</p>

<h3>References</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/
https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/
https://jackfromeast.site/2023-01/understand-the-heap-a-beautiful-mess.html
https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-part-2-d1f325b74286 
https://ir0nstone.gitbook.io/notes/types/heap/bins
http://tukan.farm/2017/07/08/tcache/
https://pwn.college/cse494-s2023/dynamic-allocator-misuse
https://codebrowser.dev/glibc/glibc/malloc/malloc.c.html
https://www.youtube.com/watch?v=A-Qf_Q_AeFw
</code></pre></div></div>


        </div>
        
      </li>
    
  </ul>

  
  <div class="pagination">
    
      <a class="previous" href="/posts/2/">&laquo; Older</a>
    

    
  </div>



</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; Zeus - Subscribe via <a href="https://hackolympus.com/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
