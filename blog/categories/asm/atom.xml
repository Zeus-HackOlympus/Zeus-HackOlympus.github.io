<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: asm | Zeus@HackOlympus:~$]]></title>
  <link href="http://hackolympus.com//blog/categories/asm/atom.xml" rel="self"/>
  <link href="http://hackolympus.com/"/>
  <updated>2022-01-04T22:55:38+05:30</updated>
  <id>http://hackolympus.com/</id>
  <author>
    <name><![CDATA[Zeus]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Writing programs in x86-64 ASM and pwncollege embryoasm writeup]]></title>
    <link href="http://hackolympus.com/blog/2022/01/04/writing-programs-in-x86-64-assembly-language/"/>
    <updated>2022-01-04T15:28:24+05:30</updated>
    <id>http://hackolympus.com/blog/2022/01/04/writing-programs-in-x86-64-assembly-language</id>
    <content type="html"><![CDATA[<p>Before reading this, it&rsquo;s an advice to please read <a href="/blog/2021/11/25/x86-64-assembly-language/">previous article</a> of ASM series.</p>

<p>So now that we know some basics of registers and syscalls. We will move onto the part where we use our newfound knowledge to write some assembly code.</p>

<p><strong>The following ASM code is specific to GAS (GNU Assembler)</strong></p>

<h3>Step by Step Hello world ASM program breakdown</h3>

<pre><code class="asm">.section .text
    .intel_syntax noprefix
    .global _start
    _start:
        mov rax, 1
        lea rsi, [rip+str]
        mov rdx, 13
        syscall

        mov rax, 60
        mov rdi, 0
        syscall

    str:
        .string "Hello world\n"
</code></pre>

<p>Now in my <a href="/blog/2021/01/24/Memory-Mapping-Introduction/">first article</a>, I explained different sections/mapping of memory. Most important sections among those are <code>.text</code> section and <code>.data</code>, because it is <code>.text</code> where we write code and <code>.data</code> where we define variables and constants.</p>

<p>In the above <em>hello world</em> program, we are only using the <code>.text</code> section and keeping the code as minimal and simple as possible.</p>

<p>So in the first line we are defining the section. In order to define a section we do <code>.section &lt;section name&gt;</code></p>

<p>In our case, as we are only using <code>.text</code> :</p>

<pre><code class="asm ">.section .text 
</code></pre>

<p>Now because we are using GAS, the default ASM sytax is AT&amp;T but we are writing in intel syntax so we need to specify that to the assembler. We do this using :</p>

<pre><code class="asm ">.intel_syntax noprefix 
</code></pre>

<p><code>.global</code> is GAS directive which helps in defining symbols in object file. Every ASM code must have a <code>_start</code> symbol. It defines the entry point of ASM code.</p>

<p>In GAS we do all this using :</p>

<pre><code class="asm ">.global _start # first we define a symbol
_start : # then we mark the entry point 
</code></pre>

<p>Oh ! by the way, we use <code>#</code> in GAS for comments.</p>

<h3>MOV instruction</h3>

<p>The <code>mov</code> instruction is the very basic and is used extensively in a assembly program.  It is used to copy/move data from one register to another. In intel, it works in the following way :</p>

<pre><code class="">mov &lt;destination register&gt; , &lt;source register&gt;
</code></pre>

<p>For example we need to copy number 6263 in register <code>rax</code>, We&rsquo;ll do :</p>

<pre><code class="asm ">mov rax, 6263 # rax = 6263
</code></pre>

<h3>LEA instruction</h3>

<p>The <code>lea</code> instruction is used to copy some <strong>address</strong> in some register.</p>

<pre><code>lea &lt;destination register&gt; , &lt;source effective address&gt;
</code></pre>

<p>This is also used extensively because we are loading effective address, So we can also do math in one instruction itself and assembler will understand it and assemble it for us. In <code>mov</code> instruction it&rsquo;s not possible.</p>

<h3>SYSCALL instruction</h3>

<p>syscall instruction, as name says, is used for making system calls.</p>

<h3>Main Hello world code</h3>

<p>Now to write something on screen, we need to write on stdout (it&rsquo;s file descriptor is 1). So in total we need to do 2 syscalls (write and exit syscalls).</p>

<p>To do write syscall we need to give it some arguments. We give arguments based on calling convention (Discussed in previous <a href="/blog/2021/11/25/x86-64-assembly-language/">article</a>) .</p>

<p><img src="http://hackolympus.com/images/x86-64/Calling_convention.png" class="center" style="width: 60%"></p>

<p>We can either use a good <a href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md">website</a> or if you are a console fan then method used in <a href="/blog/2021/11/25/x86-64-assembly-language/">previous article</a> to get syscall number and to see arguments use 2nd page of <code>man</code> command.</p>

<p><img src="http://hackolympus.com/images/x86-64/man_write.png" class="center" style="width: 90%"></p>

<p><code>echo SYS_write | gcc -include sys/syscall.h -E -</code></p>

<p>So, putting everything together and writing a subroutine for <code>write</code> syscall</p>

<p><strong>1st argument :</strong> fd (File descriptor which in our case is 1 for stdout) <br>
<strong>2nd argument :</strong> buf (Buffer, Address of info which has to be written on screen ?) <br>
<strong>3rd argument :</strong> count (Buffer size) <br></p>

<p>All these arguments have to be set according to calling convention.</p>

<pre><code class="asm ">mov rax, 1         # syscall code is set through rax register 
mov rdi, 1         # set fd to stdout (1)  
lea rsi, [rip+str] # use rip (instruction pointer) to access label str
mov rdx, 13        # Hello world\n\0 size = 13
syscall            # perform syscall 
</code></pre>

<p>Label <code>str</code> is basically a space in memory where &ldquo;hello world&rdquo; is stored in form of bytes. <code>lea</code> instruction will calculate the address of the start of buffer using <code>rip</code> register (instruction pointer).</p>

<p>I recommend you to write the <code>exit</code> subroutine without looking at my code.</p>

<p><strong>Exit subroutine :</strong></p>

<pre><code class="asm ">mov rax, 60 # syscall code for exit is 60 
mov rdi, 0  # return address of exit 
syscall     # perform syscall 
</code></pre>

<p>So to putting all the pieces together and we get our assembly code :</p>

<pre><code class="asm ">.section .text
    .intel_syntax noprefix
    .global _start
    _start:
        mov rax, 1
        lea rsi, [rip+str]
        mov rdx, 13
        syscall

        mov rax, 60
        mov rdi, 0
        syscall

    str:
        .string "Hello world\n"
</code></pre>

<p>I hope after reading this, you would have understood assembly and basic concepts related to memory. Now like any other language, assembly is just about practice, pratice and practice. Once you master it, I guarantee, assembly and C will become your favorite language.</p>

<h3><a href="https://dojo.pwn.college/challenges/asm">Pwn.College Embryoasm</a>  Writeup</h3>

<p>I have already started the instance, so let' connnect <code>ssh -i ~/.ssh/key.pub hacker@dojo.pwn.college</code> .</p>

<p><img src="http://hackolympus.com/images/x86-64/asm_1.png" class="center" style="width: 90%"></p>

<p>So this is easy. As explained above. We can just do <code>mov rdi, 0x1337</code></p>

<p>full code :</p>

<pre><code class="asm ">.section .text 
    .intel_syntax noprefix 
    .global _start 
    _start : 
        mov rdi, 0x1337
</code></pre>

<p>First we assemble it and compile it into an ELF then we will convert copy bytes of that ELF in a different file.</p>

<p>to do so :
<code>
gcc -nostdlib -static exp.s -o exp
objcopy --dump-section .text=exp.bin exp
</code></p>

<p>Then we will pipe the bytes into the challenge.</p>

<p><img src="http://hackolympus.com/images/x86-64/asm_1_flag.png" class="center" style="width: 90%"></p>

<p>We can also do this using python script through pwntools.</p>

<p>Python script :</p>

<pre><code class="py">#!/usr/bin/env python3
import pwn
pwn.context.log_level = "INFO"
pwn.context.encoding = "latin"
pwn.context.arch = "amd64"
pwn.warnings.simplefilter("ignore")

assembly = """mov rdi, 0x1337"""

proc = pwn.process("/challenge/embryoasm_level1")
print(proc.readrepeat(1).decode())
proc.send(pwn.asm(assembly))
print(proc.readrepeat(1).decode())
</code></pre>

<p>In future I&rsquo;ll write some interesting articles on some more instructions in ASM, file operations through assembly, shellcoding and operating system design.</p>

<p>A <a href="https://deut-erium.github.io/about.html">wise man</a>üë®‚Äçüíª (check out his <a href="https://deut-erium.github.io/">blog</a>) once said to me, &ldquo;its almost like playing lego &hellip; you have to put the pieces together &hellip;&rdquo;</p>

<p>On that note,</p>

<p>Signing out</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[x86-64 Assembly Language]]></title>
    <link href="http://hackolympus.com/blog/2021/11/25/x86-64-assembly-language/"/>
    <updated>2021-11-25T10:07:42+05:30</updated>
    <id>http://hackolympus.com/blog/2021/11/25/x86-64-assembly-language</id>
    <content type="html"><![CDATA[<h4>Prerequisite: Knowledge about simple programming language terms like variables, functions etc.</h4>

<h3>Registers</h3>

<p>ASM works a lot around registers, I try to think of them as variables which only store data types up to 8 bytes.Now there are special registers and register for general use.</p>

<p>In the start (during 8 bit days) we only had 4 general purpose registers - a,b,c,d.</p>

<p>And Other 2 special purpose registers - sp (stack pointer) and bp (base pointer).</p>

<p>But now (in 64 bit mode) we have a total of 11 general purpose registers and 4 special purpose registers:</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> Register </th>
<th style="text-align:center;">          Purpose         </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">    rax   </td>
<td style="text-align:center;"> General Purpose Register </td>
</tr>
<tr>
<td style="text-align:center;">    rbx   </td>
<td style="text-align:center;"> General Purpose Register </td>
</tr>
<tr>
<td style="text-align:center;">    rcx   </td>
<td style="text-align:center;"> General Purpose Register </td>
</tr>
<tr>
<td style="text-align:center;">    rdx   </td>
<td style="text-align:center;"> General Purpose Register </td>
</tr>
<tr>
<td style="text-align:center;">    r8    </td>
<td style="text-align:center;"> General Purpose Register </td>
</tr>
<tr>
<td style="text-align:center;">    r9    </td>
<td style="text-align:center;"> General Purpose Register </td>
</tr>
<tr>
<td style="text-align:center;">    r10   </td>
<td style="text-align:center;"> General Purpose Register </td>
</tr>
<tr>
<td style="text-align:center;">    r11   </td>
<td style="text-align:center;"> General Purpose Register </td>
</tr>
<tr>
<td style="text-align:center;">    r12   </td>
<td style="text-align:center;"> General Purpose Register </td>
</tr>
<tr>
<td style="text-align:center;">    r13   </td>
<td style="text-align:center;"> General Purpose Register </td>
</tr>
<tr>
<td style="text-align:center;">    r14   </td>
<td style="text-align:center;"> General Purpose Register </td>
</tr>
<tr>
<td style="text-align:center;">    r15   </td>
<td style="text-align:center;"> General Purpose Register </td>
</tr>
<tr>
<td style="text-align:center;">    rsp   </td>
<td style="text-align:center;"> Special Purpose Register </td>
</tr>
<tr>
<td style="text-align:center;">    rbp   </td>
<td style="text-align:center;"> Special Purpose Register </td>
</tr>
<tr>
<td style="text-align:center;">    rsi   </td>
<td style="text-align:center;"> Special Purpose Register </td>
</tr>
<tr>
<td style="text-align:center;">    rdi   </td>
<td style="text-align:center;"> Special Purpose Register </td>
</tr>
</tbody>
</table>


<p>In above registers &lsquo;r&rsquo; means 64 bit register. If we want to use 32 bit register we use &lsquo;e&rsquo; prefix. <strong>We can also use 32/16/8 bit registers in 64 bit mode</strong> . The following illustration will explain it clearly :</p>

<p><img src="http://hackolympus.com/images/x86-64/Registers.drawio.png" class="center" style="width: 70%"></p>

<h3>Syscall</h3>

<p>Behind the working of every program, there are syscalls involved; These syscalls are permissions which the program ask for from the &ldquo;supreme authority&rdquo; - the kernel. Now why this happens ? Because the program does not directly run in the privileged mode for security reasons.</p>

<p>In C language we have glibc that provide us functions like <code>printf</code>, <code>scanf</code> etc. which performs syscalls for us in the background.Now before making a syscall we have to set some parameters to define the syscall and its behaviour. We define the syscall using &ldquo;codes&rdquo;, for example <code>write</code> syscall has code 1 in x86-64. Now <code>write</code> takes 3 arguments: <code>fd</code>(file descriptor we have to write), <code>buf</code> (stuff we have to write), and <code>count</code> (How many characters to write). How do we know this ? using <code>man 3 write</code> which return the man page of write.</p>

<p>We set these arguments using different register and all this follows a calling convention. The calling convention is as follows:</p>

<p><img src="http://hackolympus.com/images/x86-64/Calling_convention.png" class="center" style="width: 60%"></p>

<p>To get a list of all the syscalls : <code>cat /usr/include/x86_64-linux-gnu/asm/unistd_64.h</code> We don&rsquo;t need to remember this path. I mean if you ever forget this path simply investigate this using other techniques like preprocessor output and printing predefined standard macros like this: <code>echo SYS_write | gcc -include sys/syscall.h -E -</code> here we are just asking the compiler to return the preprocessor output to stdout.</p>

<p>That&rsquo;s all folks. In next article we&rsquo;ll write our first assembly program.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memory Mapping Introduction]]></title>
    <link href="http://hackolympus.com/blog/2021/01/24/Memory-Mapping-Introduction/"/>
    <updated>2021-01-24T00:00:00+05:30</updated>
    <id>http://hackolympus.com/blog/2021/01/24/Memory-Mapping-Introduction</id>
    <content type="html"><![CDATA[<h4><strong>Memory mapping</strong></h4>

<p>Memory of computer has addresses for its smooth working. These addresses are same for everyone and does not change from use to use. The first byte is at address 0, the second byte is at address 1, and so on until the last byte of the computer&rsquo;s memory. Basically if I want to explain memory mapping in short there are memory registers that map memory. First a &ldquo;logical&rdquo; address is given to these processes which are currently running on the computer by CPU. This &ldquo;logical&rdquo; address is completely temporary and is not same for all users, its completely virtual. This process when becomes a permanent process, is assigned a &ldquo;physical&rdquo; address on the memory itself.</p>

<p>How exciting huh ? Well for me these things are very exciting üòÅ</p>

<p><strong>These mapping registers can only map data of 2 different size - 4096 bytes and 2 megabytes. Linux uses 2MB for the kernel and 4Kb for most other uses</strong>. Recent CPUs can support up to 1GB !!</p>

<p>To understand these concepts more clearly, you all can read this book (<a href="http://library.bagrintsev.me/ASM/Introduction%20to%2064bit%20Intel%20Assembly%20Language%20Programming%20for%20Linux.2011.pdf">link</a>) and watch this Youtube video by Ted-Ed <a href="https://www.youtube.com/watch?v=p3q5zWCw8J4&amp;t=22s">link</a></p>

<p>I have ended memory mapping in very short and has just given you a little overview because I can&rsquo;t explain everything here but you all can look the links that I have given you all.</p>

<p>So now comes the more exciting part. Ever heard of stack, heap etc. Well in this article you will be explained everything. That&rsquo;s why I just love assembly, It completely builds all the concepts clear related to working of computers.</p>

<h4><strong>Process Memory Model</strong></h4>

<p>For the smooth running of a process linux memory is divided into 4 logical segments- text, data, heap and stack. A process is mapped from lowest address i.e. <strong>text</strong> to the highest address i.e. <strong>stack</strong>.</p>

<p>Now before moving ahead I would like to discuss about 2 types of memory - <strong>logical and physical</strong>. <strong>The segmentation is done in the logical part</strong> of the memory because it can vary but the <strong>pages(blocks) are the part of physical part</strong> of the memory as a block size remains constant.</p>

<p><img src="http://hackolympus.com/images/process-memory-dia.png" align="left">
<br></p>

<p><strong>Text</strong> - In assembly text segment is indicated by <code>.text</code> , It contains the machine instructions of a program. It basically tells the story of what program does.</p>

<p><strong>Data</strong> - Data segment contains all the <strong>static data</strong>. It is represented by <code>.data</code> .Which means it contains all variables that have been initialized in the program.</p>

<p><strong>.bss</strong> - Above data segment, there is <code>.bss</code> segment which stands for &ldquo;block started by symbol&rdquo;. Ths segment contains data which is statistically allocated in a process, but is not stored in the executable file. Instead this data is allocated when the process is loaded into <strong>memory</strong>.</p>

<p>.<strong>rodata</strong> - Sometimes <code>.rodata</code> is also seen. Basically <code>.rodata</code> is a segment where all the constants are placed and <code>.data</code> is a segment where all the variable are placed.</p>

<p><strong>Heap</strong> - Heap is basically some space reserved by the program so that it can use it for future purposes when calling functions like <code>malloc</code>.</p>

<p><strong>Stack</strong> - It is basically temporary storage space for a process. The size of stack is set by the linux kernel, typically to 16 MB. This is enough for our processes.</p>

<p>Now the above segments is for a page(block) of memory. So basically the minimum size of segments depends on page size.</p>

<p>The size of segments vary according to usage but the ultimate size of the page will remain same. for example Sometimes, you will see that processor is processing a lot of information in that case we can assume that .text part is large but other parts is small.Sometimes processing done is less but still <code>.data</code> is large but others are small. Sometimes a process needs more temporary storage for later use so stack will be more in size.</p>

<p><strong>Hello world program in assembly.</strong></p>

<p>I do not want you to understand the whole code below. Just observe how segmentation has been performed in the code and keep this code in the back of your mind so that you can understand and write codes yourself in the upcoming articles.</p>

<pre><code class="asm">.section .text 
    .intel_syntax noprefix 
    .global _start 
    _start:
        mov rax, 1 
        lea rsi, [rip+str]   
        mov rdx, 13
        syscall 

        mov rax, 60 
        mov rdi, 0
        syscall 

    str:
        .string "Hello world\n"
</code></pre>

<p>To run this:</p>

<pre><code class="sh">gcc helloworld.s -nostdlib --static -o helloworld
./helloworld
</code></pre>

<p>I have not added a lot of things in this article. So please read and view the following sources.</p>

<p><strong>Sources:</strong></p>

<p>Book link given in the <strong>previous article.</strong></p>

<p><a href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch10s04.html">http://www.cs.uwm.edu/classe</a><a href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch10s04.html">s/cs315/Bacon/Lecture/HTML/ch10s04.htm</a><a href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch10s04.html">l</a></p>

<p><a href="https://jameshfisher.com/2018/03/10/linux-assembly-hello-world/">https://jameshfisher.com/2018/03/10/linux-assembly-hello-world/</a></p>

<p><a href="https://web.stanford.edu/class/archive/cs/cs107/cs107.1212/schedule.html">https://web.stanford.edu/class/archive/cs/cs107/cs107.1212/schedule.html</a></p>

<p><a href="https://www.youtube.com/watch?v=HWwNTWY1rxo">https://www.youtube.com/watch?v=HWwNTWY1rxo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction To Assembly Language]]></title>
    <link href="http://hackolympus.com/blog/2021/01/24/Introduction-To-Assembly-Language/"/>
    <updated>2021-01-24T00:00:00+05:30</updated>
    <id>http://hackolympus.com/blog/2021/01/24/Introduction-To-Assembly-Language</id>
    <content type="html"><![CDATA[<p>Every Computer has a processor, that processor as we have already guessed by its name, processes the information given to the computer. It performs basic operations like arithmetic calculations, logical and control operations for the computer. This processor understands 1s and 0s but for us humans to write code in 1s and 0s is very difficult and tedious so for this purpose assembly language was introduced. Assembly language makes it easy for us to communicate with computer and understand it more clearly.</p>

<p>Assembly language is often called <em>symbolic machine code</em>. It consists of a lot of short forms which is converted to machine language(1s and 0s) when passed through assembler. The following image was found online on the net, it will help you all to understand this concept more clearly.</p>

<p><img src="http://hackolympus.com/images/Assembly-Language-vs-Machine-Language-1.png" class="center" style="width: 50%"></p>

<p>The above process of converting assembly language to machine code is called as <strong><em>assembly</em></strong>.</p>

<p>Ok, so up till now I think I have made my point clear that main purpose of assembly language or should I say every programming language is to understand computer and give it commands.</p>

<p>Now a assembly language is designed depending upon which processor we are using so in short it is processor specific. So it is possible that processor found in one PC may able to assemble code written in it but processor of other PC may not.</p>

<p>Assembly language is a low level language and is often abbreviated as <strong><em>asm</em></strong>. So first of all what is a low level language ?</p>

<p>Low level language does not mean that it is easy to learn or anything. Basically low level language basically means that it is a language that it is very similar to actual machine language and has less abstraction. By abstraction I mean changes added to that language so it becomes less complex and more understandable. The converse of it can be applied for high level languages like python, C, Java etc.</p>

<p>So What exactly are these 1&rsquo;s and 0&rsquo;s ?</p>

<p>These 1s and 0s are called <em>bits</em>. It is the smallest possible storage unit of computer.</p>

<h4>Bytes</h4>

<p>So we have understood bits but what are bytes ? Are they the same thing or different. Well many people think that bits and bytes are same but its false.</p>

<p>Nowadays processor interpret a specific number of bits at a time. They interpret 8 bits at a time. <strong>This cluster of 8 bits is known as <em>a byte</em></strong>. The main memory of the computer is composed of an array of bytes, with each byte having a separate memory address. The first byte address is 0 and the last address depends on the hardware and software in use. Any byte that is identified as a machine instruction is pushed into <strong>rbp register</strong> onto the run-time stack.</p>

<p><strong>After this you all must study the following concepts as it will make your concepts more clear:</strong></p>

<ul>
<li>Binary numbers</li>
<li>Binary arithmetic - addition, subtraction, multiplication and division</li>
<li>Hexadecimal numbers</li>
<li>Floating point numbers</li>
</ul>


<p>I learned the above topics from this book :</p>

<p><a href="http://library.bagrintsev.me/ASM/Introduction%20to%2064bit%20Intel%20Assembly%20Language%20Programming%20for%20Linux.2011.pdf">Introduction to 64 Bit Intel Assembly Language Programming for Linux</a></p>
]]></content>
  </entry>
  
</feed>
